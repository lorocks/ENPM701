# -*- coding: utf-8 -*-
"""Assignment3_Autonomous.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XFxDQq7mfig6CsX-4g_w-mnW8rab3nEw
"""

import cv2
import imutils
import time
import numpy as np
import os

cap = cv2.VideoCapture(0)

frame_width = int(cap.get(3))
frame_height = int(cap.get(4))

size = (frame_width, frame_height)

result = cv2.VideoWriter('video.avi',
                         cv2.VideoWriter_fourcc(*'MJPG'),
                         10, size)

start = time.time()
time_vals = []

# Define the lower and upper color thresholds
lower = np.array([40, 60, 50])
upper = np.array([95, 255, 255])
# lower = np.array([30, 50, 40])


while cap.isOpened():
    t1 = cv2.getTickCount()
    # Read frame from the video
    ret, frame = cap.read()

    if not ret:
        break

    # Update object localizer
    # frame = cv2.flip(frame, -1)

    # Convert the image to the HSV color space
    hsv_image = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

    # Create a mask based on the color thresholds
    mask_h = cv2.inRange(hsv_image, lower, upper)

    # Apply morphological operations to remove noise
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
    # kernel = np.ones((5,5),np.uint8)
    mask = cv2.morphologyEx(mask_h, cv2.MORPH_OPEN, kernel)

    # Gaussian blurring
    # mask = cv2.GaussianBlur(mask, (9, 9),0)
    # mask = cv2.threshold(mask, 10, 255, cv2.THRESH_BINARY)[1]

    contours, hierarchy = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)

    if len(contours) > 0:
        # find the biggest countour (c) by the area
        c = max(contours, key = cv2.contourArea)
        x,y,w,h = cv2.boundingRect(c)

        x_centroid = x + (w/2)
        y_centroid = y + (h/2)

        # Find corners
        feature_params = dict(maxCorners=7,
                                qualityLevel=0.05,
                                minDistance=1,
                                blockSize=10)
        
        corners = cv2.goodFeaturesToTrack(mask, mask=None, **feature_params)
        # corners = cv2.goodFeaturesToTrack(mask, 7, 0.05, 1)

        x_diff = y_diff = 0

        try:
            corners = np.intp(corners)
            for i in corners:
                x,y = i.ravel()
                cv2.circle(frame,(x,y),3,255,-1)

                x_diff += x - x_centroid
                y_diff += y - y_centroid
        except:
            pass

        if abs(x_diff) > abs(y_diff): # right or left
            if x_diff > 0:
                cv2.putText(frame, 'Right', (30, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 0), 2, cv2.LINE_AA)
            else:
                cv2.putText(frame, 'Left', (30, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 0), 2, cv2.LINE_AA)
        else:
            if y_diff > 0:
                cv2.putText(frame, 'Down', (30, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 0), 2, cv2.LINE_AA)
            else:
                cv2.putText(frame, 'Up', (30, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 0), 2, cv2.LINE_AA)


    cv2.imshow("Video Stream", frame)
    # cv2.imshow("hsv", mask_h)

    result.write(frame)

    t2 = cv2.getTickCount()
    time1 = (t2 - t1) / cv2.getTickFrequency()
    print(f"Time taken {time1}")
    time_vals.append(time1)
    # time_s = time1

    # Press key q to stop
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

    # if time.time() - start > 30:
	# 	break

cv2.destroyAllWindows()
cap.release()
result.release()

print("Writing data to file")

if os.path.exists("hw4data.txt"):
  os.remove("hw4data.txt")
else:
  print("The file does not exist")

f = open('hw4data.txt', 'a')
for val in time_vals:
  f.write(str(val))
  f.write('\n')
f.close()
